# Almost Sorted - HackerRank

## Бодлогын тайлбар

Танд `n` урттай массив өгөгдөнө. Энэхүү массивыг **swap** эсвэл **reverse** үйлдлүүдийн аль нэгийг **зөвхөн нэг удаа** ашиглан бүхэлд нь өсөх дараалалд оруулах боломжтой эсэхийг шалгана.

Хэрвээ боломжтой бол:

- `yes` гэж хэвлэнэ
- Дараа нь `swap i j` эсвэл `reverse i j` гэж үйлдлийг гаргана

---

## Бодлогын холбоос

[Almost Sorted - HackerRank](https://www.hackerrank.com/challenges/almost-sorted/)

---

## Нотолгоо ба шийдэл

1. Массивыг зүүнээс баруун тийш харж `arr[i] > arr[i+1]` анхны алдааг олж `l`-г тодорхойлно.
2. Баруунаас зүүн тийш мөн адил алдааг олж `r`-г тодорхойлно.
3. `l` ба `r` байрлалын хооронд:
   - Эхлээд `swap(l, r)` хийж sorted эсэхийг шалгана.
   - Хэрвээ sorted биш бол `reverse(l, r)` хийж дахин шалгана.
4. Аль аль нь sorted биш бол `no` гэж хэвлэнэ.

---

## Жишээ

**Оролт:**
6
1 5 4 3 2 6

**Гаралт:**
yes
reverse 2 5

## Директор бүтэц

HackerRank
├── Algorithm
| ├── Bodlogo16
| | ├── AlmostSorted.java
| | └── README.md
